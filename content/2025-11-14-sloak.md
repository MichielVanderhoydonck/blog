+++
title = "Building SLOAK: A Case Study in Testable Go Architecture"
date = "2025-09-24"
description = "Evolving the standard go project layout to a hexagonal/layered testable structure."
[taxonomies]
tags = ["SLO","SLI","SLA","Golang","Architecture"]
+++

# What's Wrong With The Standard?!

Frankly, nothing. The main driver for this alternate approach is to have an easier time with the classic "what to put where" problem and to avoid the common shortcut of "parking things there for now."
So then, where do we begin? The choice should mostly boil down to what your programming language advises. For Golang, we can find a great example here.
It's great, and it gets you started quickly with common directories like cmd, internal, and pkg. It's within these folders that we often add odd dependencies when we're not careful, especially when adding quick changes and additions. But what can we add to that structure to improve it?

# Don't Fight The Framework

We often resort to frameworks so we don't have to reinvent the wheel, or we leverage amazing open-source software to fulfill our mad ideas.
Luckily, these frameworks often come with a structure and are well-documented. For the sake of not making things harder for ourselves, we should adhere to their rules for the most part.
If you agree with this, we'll likely move on to looking at the flow of dependency instead.

## An Onion-like Flow

We often aim to work with a "domain" and try to keep it clean of specifics that aren't related to it, like the type of database used or its presentation entrypoint.
To help with that, I chose to adopt hexagonal architecture. The dependency rule is simple: dependencies flow inward, from the outer layers (like adapters) toward the core (the domain).
We'll dive into how we can enforce that later, but first, let's look at the folder structure we can use to combine our project layout with the intended architecture, all without disrupting framework flows.

## Domains, Ports, and Services

Starting from the core and working outwards, we need our domain and services. Let's uncover where we put what.
Our project will be a CLI performing SRE-related calculations, such as burnrate and errorbudget.
We'll make the following structure: internal/core/domain/errorbudget/ (from the project root), where we can define our domain objects in files like budget.go.
Next to the domain, within the core, we can also define services—internal/core/service/errorbudget/—which will encapsulate the business logic for our domain (e.g., the calculations we aim to provide).
Note that these services implement the interfaces (ports) of our domain, which live in internal/core/port/errorbudget/. As is tradition in Go, tests should live close to the tested file, so no need to change that!

## Adapt, Assemble!

We've made good progress, but we need to provide our end users with a way to make use of our services. For that, we'll implement Cobra commands, since the CLI will be our Driving Adapter.
These commands reside in their domain-related folder within cmd, resulting in structures like cmd/errorbudget/errorbudget.go. All these domain-related commands are bootstrapped onto our Cobra application via root.go, which is then called by our main.go, following regular conventions.

With all that in place, our structure looks as follows:
```bash
.
├── cmd
│   ├── burnrate
│   │   ├── burnrate_test.go
│   │   └── burnrate.go
│   ├── calculate.go
│   ├── errorbudget
│   │   ├── errorbudget_test.go
│   │   └── errorbudget.go
│   ├── root.go
│   └── sloak
│       └── main.go
├── internal
│   ├── adapter
│   │   └── README.md
│   ├── core
│   │   ├── domain
│   │   │   ├── burnrate
│   │   │   │   └── burnrate.go
│   │   │   ├── common
│   │   │   │   ├── slo_test.go
│   │   │   │   └── slo.go
│   │   │   └── errorbudget
│   │   │       └── budget.go
│   │   ├── port
│   │   │   ├── burnrate
│   │   │   │   └── port.go
│   │   │   └── errorbudget
│   │   │       └── port.go
│   │   └── service
│   │       ├── burnrate
│   │       │   ├── service_test.go
│   │       │   └── service.go
│   │       └── errorbudget
│   │           ├── service_test.go
│   │           └── service.go
│   └── util
│       ├── time_test.go
│       └── time.go
├── README.md
...
```


# Enforcing Design

These rules are all nice and dandy, but we need a way to ensure we keep following them. For that purpose, I added a go-arch-lint config to keep our lovely design lasagna correct in each layer.

# What's Next?

Well, like all side projects or tryouts, ~~they go on the backburner and never get finished~~ I'll try to expand and iterate on the commands, hopefully landing a sweet SRE tool for people to use in the future.
Feel free to have a peek at the repository and let me know what you think!

Thanks for joining me in this madness—see you on our next venture!